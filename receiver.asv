classdef receiver < communicator
    % parent class for Alice and Bob
    properties
        
    end
    methods
        function plain_text = binaryToMessage(obj,binaryMessage)
            % Converts a binary char array back to a text string
            %
            % Inputs:
            %   binaryStr    - Binary string (e.g., '0100100001100101')
            %   bitsPerChar  - Optional: Number of bits per character (default: 8)
            %
            % Output:
            %   textStr      - Reconstructed string (e.g., 'He')
            binaryStr = char(binaryMessage);
            bitsPerChar = 8; % Default to ASCII (8 bits)
        
            % Ensure input is a char array of '0's and '1's
            if ~ischar(binaryStr) || any(~ismember(binaryStr, '01'))
                error('Input must be a char array of ''0''s and ''1''s.');
            end
        
            % Pad with zeros if length is not a multiple of bitsPerChar
            if mod(length(binaryStr), bitsPerChar) ~= 0
                padding = bitsPerChar - mod(length(binaryStr), bitsPerChar);
                binaryStr = [binaryStr, repmat('0', 1, padding)];
                warning('Input padded with %d zeros to match bit grouping.', padding);
            end
        
            % Split binary into chunks of 'bitsPerChar' bits
            numChars = length(binaryStr) / bitsPerChar;
            binaryChunks = reshape(binaryStr, bitsPerChar, numChars)';
        
            % Convert each chunk to decimal, then to char
            decimalValues = bin2dec(binaryChunks);
            plain_text = char(decimalValues)';
        end
        function decoded_message = decode(obj,encrypted_message)
            DecryptedCircuit = obj.functions.decrypt_clifford(obj.clifford_gates{1}); 
            cliffordDecrypt = DecryptedCircuit;
            p = obj.permutations(1, :);
            swap_gates = obj.functions.permutationToSwapGates(p);
            rev_swap_gates = obj.functions.reverseSwapGates(swap_gates);
            gates = [cliffordDecrypt; rev_swap_gates;];
            D = quantumCircuit(gates);
            decoded_message = {}
            for i = 1:length(encrypted_message)
                s = simulate(D,encrypted_message{i});
                bits = measureQuantumState(s);
                
                disp(formula(s)); 
            end
        end
        function measuredBits = measureQuantumState(obj,state)
            binaryStrings = generateBinaryStrings(obj.block_size+obj.sign_size);
            measuredBits = ""
            for i=1:length(binaryStrings)
                p = probability(state,(1:(obj.block_size+obj.sign_size)))
                if p == 1
                    measuredBits = binaryStrings(i)
                end
            end
        end
        function binaryStrings = generateBinaryStrings(obj, n)
            % Generates all binary strings of length n
            % Output: A matrix where each row is a binary string
            
            numStrings = 2^n; % Total number of binary strings
            binaryStrings = dec2bin(0:numStrings-1) - '0'; % Generate and convert to numeric matrix
        end
    end
end